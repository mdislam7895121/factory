#!/usr/bin/env node

import fs from 'node:fs';
import path from 'node:path';

const RESERVED_NAMES = new Set(['api', 'web', 'mobile', 'apps', 'docs', 'scripts']);
const NAME_PATTERN = /^[a-z][a-z0-9-]{2,39}$/;
const DATABASE_VALUES = new Set(['postgres', 'sqlite']);

const FILE_MAP = [
  { path: 'README.md', source: 'template:root/README.md.hbs' },
  { path: '.gitignore', source: 'template:root/.gitignore.hbs' },
  { path: '.env.example', source: 'template:root/.env.example.hbs' },
  { path: 'apps/api/package.json', source: 'template:apps/api/package.json.hbs' },
  { path: 'apps/api/tsconfig.json', source: 'template:apps/api/tsconfig.json.hbs' },
  { path: 'apps/api/src/main.ts', source: 'template:apps/api/src/main.ts.hbs' },
  { path: 'apps/web/package.json', source: 'template:apps/web/package.json.hbs' },
  { path: 'apps/web/next.config.js', source: 'template:apps/web/next.config.js.hbs' },
  { path: 'apps/web/tsconfig.json', source: 'template:apps/web/tsconfig.json.hbs' },
  { path: 'apps/web/src/app/layout.tsx', source: 'template:apps/web/src/app/layout.tsx.hbs' },
  { path: 'apps/web/src/app/page.tsx', source: 'template:apps/web/src/app/page.tsx.hbs' },
  { path: 'packages/shared/package.json', source: 'template:packages/shared/package.json.hbs' },
  { path: 'packages/shared/src/index.ts', source: 'template:packages/shared/src/index.ts.hbs' },
  { path: 'packages/shared/src/types.ts', source: 'template:packages/shared/src/types.ts.hbs' },
];

function normalizeSlashes(value) {
  return value.replaceAll('\\', '/');
}

function getTargetFolder(normalizedInputs) {
  if (normalizedInputs.outputDir === '.') {
    return `./${normalizedInputs.name}`;
  }

  return `${normalizeSlashes(normalizedInputs.outputDir)}/${normalizedInputs.name}`;
}

function getSortedFiles() {
  return FILE_MAP
    .slice()
    .sort((left, right) => left.path.localeCompare(right.path))
    .map((entry) => ({
      path: entry.path,
      action: 'CREATE',
      source: entry.source,
    }));
}

function countDirs(files) {
  const dirs = new Set();
  for (const entry of files) {
    const slashIndex = entry.path.lastIndexOf('/');
    if (slashIndex > 0) {
      dirs.add(entry.path.slice(0, slashIndex));
    }
  }

  return dirs.size;
}

function isSubPath(parentPath, childPath) {
  const normalizedParent = path.resolve(parentPath).toLowerCase();
  const normalizedChild = path.resolve(childPath).toLowerCase();
  return normalizedChild === normalizedParent || normalizedChild.startsWith(`${normalizedParent}${path.sep}`);
}

function renderFile(pathName, inputs) {
  const { name, withAuth, database } = inputs;
  const authLabel = withAuth ? 'enabled' : 'disabled';

  if (pathName === 'README.md') {
    return [
      `# ${name}`,
      '',
      'Generated by fullstack-v1 write mode (Step 4).',
      '',
      `- withAuth: ${withAuth}`,
      `- database: ${database}`,
      '',
    ].join('\n');
  }

  if (pathName === '.gitignore') {
    return ['node_modules/', '.env', '.next/', 'dist/', 'coverage/', ''].join('\n');
  }

  if (pathName === '.env.example') {
    return [
      'NODE_ENV=development',
      'WEB_PORT=3000',
      'API_PORT=3001',
      'MOBILE_API_BASE_URL=http://localhost:3001',
      `DATABASE_PROVIDER=${database}`,
      'DATABASE_URL=postgresql://USER:PASSWORD@localhost:5432/DB_NAME',
      `WITH_AUTH=${withAuth}`,
      'JWT_SECRET=CHANGE_ME',
      '',
    ].join('\n');
  }

  if (pathName === 'apps/api/package.json') {
    return `${JSON.stringify({
      name: `${name}-api`,
      private: true,
      version: '0.1.0',
      type: 'module',
      scripts: {
        start: 'node src/main.ts',
      },
    }, null, 2)}\n`;
  }

  if (pathName === 'apps/api/tsconfig.json') {
    return `${JSON.stringify({
      compilerOptions: {
        target: 'ES2022',
        module: 'ESNext',
        moduleResolution: 'NodeNext',
        strict: true,
      },
      include: ['src/**/*'],
    }, null, 2)}\n`;
  }

  if (pathName === 'apps/api/src/main.ts') {
    return [
      '// fullstack-v1 Step 4 API placeholder',
      `console.log('api ready: ${name} (${authLabel}, ${database})');`,
      '',
    ].join('\n');
  }

  if (pathName === 'apps/web/package.json') {
    return `${JSON.stringify({
      name: `${name}-web`,
      private: true,
      version: '0.1.0',
      scripts: {
        dev: 'next dev',
        build: 'next build',
      },
    }, null, 2)}\n`;
  }

  if (pathName === 'apps/web/next.config.js') {
    return ['/** @type {import("next").NextConfig} */', 'const nextConfig = {};', '', 'module.exports = nextConfig;', ''].join('\n');
  }

  if (pathName === 'apps/web/tsconfig.json') {
    return `${JSON.stringify({
      compilerOptions: {
        target: 'ES2022',
        lib: ['dom', 'dom.iterable', 'esnext'],
        strict: true,
      },
      include: ['src/**/*'],
    }, null, 2)}\n`;
  }

  if (pathName === 'apps/web/src/app/layout.tsx') {
    return [
      'export default function RootLayout({ children }: { children: React.ReactNode }) {',
      '  return (',
      '    <html lang="en">',
      '      <body>{children}</body>',
      '    </html>',
      '  );',
      '}',
      '',
    ].join('\n');
  }

  if (pathName === 'apps/web/src/app/page.tsx') {
    return [
      'export default function HomePage() {',
      '  return <main>fullstack-v1 Step 4 web placeholder</main>;',
      '}',
      '',
    ].join('\n');
  }

  if (pathName === 'packages/shared/package.json') {
    return `${JSON.stringify({
      name: `${name}-shared`,
      private: true,
      version: '0.1.0',
      type: 'module',
    }, null, 2)}\n`;
  }

  if (pathName === 'packages/shared/src/index.ts') {
    return ['export * from "./types";', ''].join('\n');
  }

  if (pathName === 'packages/shared/src/types.ts') {
    return [
      '// fullstack-v1 Step 4 shared placeholder',
      'export type ProjectTemplateOptions = {',
      `  name: '${name}';`,
      `  withAuth: ${withAuth};`,
      `  database: '${database}';`,
      '};',
      '',
    ].join('\n');
  }

  return `// Unknown template entry: ${pathName}\n`;
}

function parseArgs(argv) {
  const args = argv.slice(2);
  const command = args[0];
  const flags = {};

  for (let index = 1; index < args.length; index += 1) {
    const token = args[index];
    if (!token.startsWith('--')) {
      continue;
    }

    const key = token.slice(2);
    const nextToken = args[index + 1];
    if (!nextToken || nextToken.startsWith('--')) {
      flags[key] = true;
      continue;
    }

    flags[key] = nextToken;
    index += 1;
  }

  return { command, flags };
}

function normalizeBoolean(rawValue, fallback) {
  if (rawValue === undefined) {
    return fallback;
  }

  if (typeof rawValue === 'boolean') {
    return rawValue;
  }

  if (typeof rawValue === 'string') {
    if (rawValue.toLowerCase() === 'true') {
      return true;
    }

    if (rawValue.toLowerCase() === 'false') {
      return false;
    }
  }

  return rawValue;
}

function validateInputs(rawInputs) {
  const issues = [];
  const normalized = {
    name: typeof rawInputs.name === 'string' ? rawInputs.name.trim() : rawInputs.name,
    withAuth: normalizeBoolean(rawInputs.withAuth, false),
    database: typeof rawInputs.database === 'string' && rawInputs.database.length > 0
      ? rawInputs.database
      : 'postgres',
    outputDir: typeof rawInputs.outputDir === 'string' && rawInputs.outputDir.length > 0
      ? rawInputs.outputDir
      : '.',
  };

  if (typeof normalized.name !== 'string' || normalized.name.length === 0) {
    issues.push({ field: 'name', message: 'name is required' });
  } else {
    if (!NAME_PATTERN.test(normalized.name)) {
      issues.push({ field: 'name', message: 'name must match ^[a-z][a-z0-9-]{2,39}$' });
    }

    if (RESERVED_NAMES.has(normalized.name)) {
      issues.push({ field: 'name', message: 'name must not be a reserved name' });
    }
  }

  if (typeof normalized.withAuth !== 'boolean') {
    issues.push({ field: 'withAuth', message: 'withAuth must be a boolean' });
  }

  if (typeof normalized.database !== 'string' || !DATABASE_VALUES.has(normalized.database)) {
    issues.push({ field: 'database', message: 'database must be one of: postgres, sqlite' });
  }

  return { normalized, issues };
}

function buildPlan(rawInputs) {
  const { normalized, issues } = validateInputs(rawInputs);

  if (issues.length > 0) {
    return {
      ok: false,
      error: 'ValidationError',
      issues,
    };
  }

  const targetRoot = getTargetFolder(normalized);
  const files = getSortedFiles();

  return {
    ok: true,
    templateId: 'fullstack-v1',
    mode: 'plan',
    inputs: {
      name: normalized.name,
      withAuth: normalized.withAuth,
      database: normalized.database,
      outputDir: normalized.outputDir,
    },
    output: {
      rule: 'targetDir = outputDir ? outputDir + "/" + name : "./" + name',
      targetFolder: targetRoot,
    },
    files,
    counts: {
      totalFiles: files.length,
      totalDirs: countDirs(files),
    },
  };
}

function writeMode(rawInputs, forceWrite) {
  const plan = buildPlan(rawInputs);

  if (!plan.ok) {
    return plan;
  }

  const targetFolder = plan.output.targetFolder;
  const targetFolderAbs = path.resolve(process.cwd(), targetFolder);

  if (fs.existsSync(targetFolderAbs)) {
    const existingEntries = fs.readdirSync(targetFolderAbs);
    if (existingEntries.length > 0 && !forceWrite) {
      return {
        ok: false,
        error: 'TargetNotEmpty',
        message: 'target folder exists and is not empty; use --force to overwrite known files',
        targetFolder,
      };
    }
  }

  fs.mkdirSync(targetFolderAbs, { recursive: true });

  const createdFiles = [];
  const overwrittenFiles = [];

  for (const file of plan.files) {
    if (path.isAbsolute(file.path)) {
      return {
        ok: false,
        error: 'PathTraversalGuard',
        message: `absolute paths are not allowed: ${file.path}`,
      };
    }

    const normalizedPath = normalizeSlashes(file.path);
    const segments = normalizedPath.split('/');
    if (segments.includes('..')) {
      return {
        ok: false,
        error: 'PathTraversalGuard',
        message: `parent traversal is not allowed: ${file.path}`,
      };
    }

    const absoluteFilePath = path.resolve(targetFolderAbs, ...segments);
    if (!isSubPath(targetFolderAbs, absoluteFilePath)) {
      return {
        ok: false,
        error: 'PathTraversalGuard',
        message: `path escapes target folder: ${file.path}`,
      };
    }

    const alreadyExists = fs.existsSync(absoluteFilePath);
    fs.mkdirSync(path.dirname(absoluteFilePath), { recursive: true });
    const content = renderFile(file.path, plan.inputs);
    fs.writeFileSync(absoluteFilePath, content, 'utf8');

    if (alreadyExists) {
      overwrittenFiles.push(file.path);
    } else {
      createdFiles.push(file.path);
    }
  }

  return {
    ok: true,
    templateId: 'fullstack-v1',
    mode: 'write',
    inputs: plan.inputs,
    output: plan.output,
    counts: plan.counts,
    files: plan.files,
    write: {
      force: Boolean(forceWrite),
      createdFiles,
      overwrittenFiles,
    },
  };
}

function printUsage() {
  process.stdout.write(
    [
      'fullstack-v1 plan mode CLI',
      '',
      'Usage:',
      '  node templates/fullstack-v1/bin/fullstack-v1.mjs plan --name <value> [--withAuth true|false] [--database postgres|sqlite] [--outputDir <dir>] [--json]',
      '  node templates/fullstack-v1/bin/fullstack-v1.mjs write --name <value> [--withAuth true|false] [--database postgres|sqlite] [--outputDir <dir>] [--force] [--json]',
      '',
    ].join('\n'),
  );
}

function main() {
  const { command, flags } = parseArgs(process.argv);

  if (!command || command === '--help' || command === '-h') {
    printUsage();
    return;
  }

  if (command !== 'plan' && command !== 'write') {
    process.stderr.write('Unsupported command. Available commands: plan, write.\n');
    process.exitCode = 1;
    return;
  }

  const baseInputs = {
    name: flags.name,
    withAuth: flags.withAuth,
    database: flags.database,
    outputDir: flags.outputDir,
  };

  const result = command === 'plan'
    ? buildPlan(baseInputs)
    : writeMode(baseInputs, flags.force === true);

  const payload = `${JSON.stringify(result, null, 2)}\n`;
  process.stdout.write(payload);

  if (!result.ok) {
    process.exitCode = 1;
  }
}

main();
